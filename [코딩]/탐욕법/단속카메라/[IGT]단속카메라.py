def solution(routes):
    routes.sort(key=lambda x:x[0])
    # input으로 받은 좌표값들을 (x,y)라고 할 때, x값이 작은 순서로 오름차순 배열(좌표평면 기준 제일 왼쪽에 있는 것부터)
    camera = routes[0] # 카메라 설치 가능 구역(이하 카메라 구역)
    answer = 1
    for i in routes[1:]:
        if i[0] <= camera[1]: # 주어진 좌표의 x값(자동차의 진입 지점)이 카메라 구역의 끝 지점보다 왼쪽에 있는가?(겹치는가?)
            camera = [i[0], min(camera[1],i[1])]
            # 카메라 구역의 시작 지점을 해당 자동차의 진입 지점(오름차순 정렬이라 기존 값보다 항상 크거나 같음)으로 변경(전체 길이 단축)하고,
            # 만약 자동차가 카메라 구역의 끝 지점에 도달하기 전에 나간다면, 마찬가지로 카메라의 끝 지점도 변경(전체 길이 단축)
        else:
            camera = i
            # 겹치지 않는다면 새로운 카메라를 설치
            # 이후, 새로 설치된 카메라의 좌표를 자동차의 출입 좌표와 비교하게 됨
            answer += 1
    return answer



def solution(routes):
    routes.sort(key=lambda x:x[1])
    # input으로 받은 좌표값들을 (x,y)라고 할 때, y값이 작은 순서로 오름차순 배열
    camera = routes[0][1]
    # 카메라를 설치하는 곳은 자동차가 지나가는 범위 내여야 함
    # 따라서 카메라 설치 가능 구역의 맨 끝(오른쪽) 지점에 설치하려고 함
    # 그러므로 첫 번째로 설치하는 카메라는 첫 번째 자동차가 빠져나가는 맨 끝 지점에 설치해야 함
  
    # 카메라를 맨 끝 지점에 설치하는 이유는 우리는 자동차의 출입 구역과 카메라의 설치 가능 구역을 비교하는 것이고
    # 그 과정에서 카메라의 설치 가능 구역의 시작이 어디인지는 설치하는 데 있어서 영향을 미치지 않기 때문
    # 즉, 카메라 설치 가능 구역의 끝 지점과 다음 자동차의 진입 지점만 서로 비교하는 것만으로 충분함
    # 카메라는 오른쪽 맨 끝에만 놓으면 되니 필요한 정보는 y좌표뿐(camera = camera[1])
    # 카메라는 오른쪽 맨 끝에만 놓이기 때문에 다음 들어오는 자동차의 시작 지점이 어디인가는 아무런 영향이 없음
  
    answer = 1
    for i in routes[1:]:
        if i[0] > camera: # 안 겹침?
            camera = i[1] # ㅇㅇ 안겹침 > 카메라 새로 설치해서 앞으로는 얘하고만 비교할 거
            answer += 1
        # 만약 겹치면(else) 기존 카메라의 y좌표와 자동차의 x좌표 중 작은 값으로 바꿔야 함
        # routes를 처음부터 y좌표 기준으로 오름차순 정렬하면 이 과정이 필요없음(카메라의 y좌표가 항상 더 작기 때문)
    return answer
